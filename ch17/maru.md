<aside>
💡 **[ 이번 장에서 살펴볼 내용 ]**

- 타임라인을 조율하기 위한 동시성 기본형을 만들어 봅니다.
- 시간에 관한 중요한 관점인 순서와 반복을 함수형 개발자들이 어떻게 다루는지 배웁니다.
</aside>

시간을 다룰 수 있는 대상으로 생각하기 (시간을 일급으로 다룸)

호출 순서와 반복을 직접 다룰 수 있음

cost_ajax와 shipping_ajax를 순서대로 호출하지 않고 거의 동시에 호출하니 호출 순서가 바뀔 수 있음

- 느리게 동작하는 코드 : 첫 번째 응답이 와야 두 번째 요청을 한다
- 실패하지만 빠르게 동작하는 새로운 코드 : 요청은 순서대로 하는데, 응답 순서를 알 수 없음

<aside>
💡 실패하지 않고 병렬로 응답을 기다려 실행 속도를 개선할 수 있는 방법은?

</aside>

### 요청 순서대로 응답이 오지 않는 이유

요청에 대한 응답이 순서에 맞지 않게 오는 원인이 많음

- cost_ajax 응답의 크기가 커서 다운로드하는 데 시간이 오래 걸림
- 배송 API 서버보다 cost_ajax를 처리하는 서버가 더 바쁨
- 이동 중인 차 안에서 핸드폰으로 cost_ajax 요청을 보냈지만, 기지국이 바뀌는 동안 지연이 생김

# 모든 병렬 콜백 기다리기

컷(Cut): 순서를 보장해주는 역할을 하며, 점선과 다르게 여러 타임라인의 끝에 맞춰 그림

컷 위에 있는 단계는 **컷 아래 단계가 실행되기 전에 모두 끝나야함**

### 동시성 기본형 구현

어떤 타임라인 작업이 끝났을 때 이 함수를 부를 것

이 함수는 호출될 때마다 호출된 횟수 증가

```tsx
function Cut(num, callback){
	var num_finished = 0;
	return function(){
		num_finished += 1;
		if(num_finished --- num)
			callback();
	};
}

var done = Cut(3, function(){ console.log('!'); };

done();
done();
done();

// '!'
```

- done을 항상 타임라인 끝에서 호출
- 컷이 필요한 타임라인의 끝에서 호출

### Cut을 활용하여 실패하지 않는 병렬 실행

- 점선 안에 있는 단계의 순서는 불확실
  - 각각의 ajax를 다른 타임라인으로 두고, ajax가 끝날 때마다 done 함수를 호출
  - done을 2번 호출하고 그 뒤에 dom을 업데이트하는 함수를 호출
  - Cut은 마지막으로 실행되는 타임라인이 done을 부르면 콜백 실행

### 딱 한번만 호출하는 기본형

함수를 호출하면 alreadyCalled를 true로 바꿔 함수가 1번만 호출되도록 하는 함수

```tsx
function JustOnce(action) {
  var alreadyCalled = false;
  return function (a, b, c) {
    if (alreadyCalled) return;
    alreadyCalled = true;
    return action(a, b, c);
  };
}
```

# 암묵적 시간 모델 vs 명시적 시간 모델

자바스크립트의 시간 모델

1. 순차적 구문은 순서대로 실행
2. 두 타임라인에 있는 단계는 왼쪽 또는 오른쪽 먼저 실행될 수 있음
3. 비동기 이벤트는 새로운 타임라인에서 실행
4. 액션은 호출할 때마다 실행
